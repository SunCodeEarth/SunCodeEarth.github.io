[["spatialops.html", "Chapter 2 Spatial data manipulation in R 2.1 Attribute Join 2.2 Attribute Selection (or non-spatial subsetting) 2.3 Spatial Query 2.4 Reprojecting or Projection Transform 2.5 Spatial Join and Aggregation: Points in Polygons 2.6 Spatial Operations 2.7 Information for Raster Operations 2.8 Lab Assignment", " Chapter 2 Spatial data manipulation in R Learning Objectives Join attribute data to a polygon vector file Select data using attribute and spatial relationships Reproject spatial data Aggregate spatial data using spatial relationships There are a wide variety of spatial, topological, and attribute data operations we can perform with R. Lovelace et al’s recent publication1 goes into great depth about this and is highly recommended. In this section we will look at just a few examples for libraries and functions that allow us to process spatial data in R and perform some commonly used operations. 2.1 Attribute Join An attribute join on vector data brings tabular data into a geographic context. It refers to the process of joining data in tabular format to data in a format that holds the geometries (polygon, line, or point)2. If you have done attribute joins of shapefiles in GIS software like ArcGIS or QGIS you know that you need a unique identifier in both the attribute table of the Shapefile and the table to be joined. First we will load the CSV table nyc_census_tracts_pophu.csv into a tibble dataframe in R tidyverse and name it nyc_pophu for population and housing unit information. nyc_pophu &lt;- readr::read_csv(&quot;data/nyc/nyc_census_tracts_pophu.csv&quot;, lazy = FALSE) str(nyc_pophu) #&gt; spc_tbl_ [2,164 × 12] (S3: spec_tbl_df/tbl_df/tbl/data.frame) #&gt; $ GEOID10 : num [1:2164] 3.6e+10 3.6e+10 3.6e+10 3.6e+10 3.6e+10 ... #&gt; $ STATEFP : num [1:2164] 36 36 36 36 36 36 36 36 36 36 ... #&gt; $ COUNTYFP : chr [1:2164] &quot;005&quot; &quot;005&quot; &quot;005&quot; &quot;005&quot; ... #&gt; $ TRACTCE : chr [1:2164] &quot;002300&quot; &quot;002701&quot; &quot;004100&quot; &quot;004800&quot; ... #&gt; $ AFFGEOID : chr [1:2164] &quot;1400000US36005002300&quot; &quot;1400000US36005002701&quot; &quot;1400000US36005004100&quot; &quot;1400000US36005004800&quot; ... #&gt; $ POPULATION: num [1:2164] 4774 3016 6476 3999 7421 ... #&gt; $ MEDAGE : num [1:2164] 29 29 23 30 28 28 29 44 38 39 ... #&gt; $ MEDHHINC : num [1:2164] 14479 20153 18636 30301 21016 ... #&gt; $ MEDHOUSING: num [1:2164] 406 627 655 1066 753 ... #&gt; $ PCPREWAR : num [1:2164] 26.8 40.6 31.3 51.1 37.3 55.5 52 19.7 18.9 18.7 ... #&gt; $ MEDYRBUILT: num [1:2164] 1957 1952 1955 1942 1950 ... #&gt; $ DENSITY : num [1:2164] 118158 94522 90795 68668 90478 ... #&gt; - attr(*, &quot;spec&quot;)= #&gt; .. cols( #&gt; .. GEOID10 = col_double(), #&gt; .. STATEFP = col_double(), #&gt; .. COUNTYFP = col_character(), #&gt; .. TRACTCE = col_character(), #&gt; .. AFFGEOID = col_character(), #&gt; .. POPULATION = col_double(), #&gt; .. MEDAGE = col_double(), #&gt; .. MEDHHINC = col_double(), #&gt; .. MEDHOUSING = col_double(), #&gt; .. PCPREWAR = col_double(), #&gt; .. MEDYRBUILT = col_double(), #&gt; .. DENSITY = col_double() #&gt; .. ) #&gt; - attr(*, &quot;problems&quot;)=&lt;externalptr&gt; 2.1.1 How to do this in sf Now let’s read the spatial data from a Shapefile into a sf object. Check out the column names of nyc_census_tracts_sf and of nyc_pophu to determine which one might contain the unique identifier for the join. nyc_census_tracts_sf &lt;- st_read(&#39;data/nyc/nyc_census_tracts.shp&#39;) #&gt; Reading layer `nyc_census_tracts&#39; from data source #&gt; `D:\\Cloud_Drive\\Dropbox (Hunter College)\\Workspace\\RSpace\\R-Spatial_Book\\data\\nyc\\nyc_census_tracts.shp&#39; #&gt; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 2162 features and 10 fields #&gt; Geometry type: MULTIPOLYGON #&gt; Dimension: XY #&gt; Bounding box: xmin: -74.25559 ymin: 40.5021 xmax: -73.70002 ymax: 40.91526 #&gt; Geodetic CRS: NAD83 str(nyc_census_tracts_sf) #&gt; Classes &#39;sf&#39; and &#39;data.frame&#39;: 2162 obs. of 11 variables: #&gt; $ GEOID : chr &quot;36061000100&quot; &quot;36061001401&quot; &quot;36061000201&quot; &quot;36061000600&quot; ... #&gt; $ STATEFP : chr &quot;36&quot; &quot;36&quot; &quot;36&quot; &quot;36&quot; ... #&gt; $ COUNTYFP: chr &quot;061&quot; &quot;061&quot; &quot;061&quot; &quot;061&quot; ... #&gt; $ TRACTCE : chr &quot;000100&quot; &quot;001401&quot; &quot;000201&quot; &quot;000600&quot; ... #&gt; $ AFFGEOID: chr &quot;1400000US36061000100&quot; &quot;1400000US36061001401&quot; &quot;1400000US36061000201&quot; &quot;1400000US36061000600&quot; ... #&gt; $ NAME : chr &quot;1&quot; &quot;14.01&quot; &quot;2.01&quot; &quot;6&quot; ... #&gt; $ LSAD : chr &quot;CT&quot; &quot;CT&quot; &quot;CT&quot; &quot;CT&quot; ... #&gt; $ ALAND : num 78638 93510 90233 240406 310039 ... #&gt; $ AWATER : num 0 0 75976 176018 428737 ... #&gt; $ CBSA : chr &quot;New York-Newark-Jersey City, NY-NJ-PA&quot; &quot;New York-Newark-Jersey City, NY-NJ-PA&quot; &quot;New York-Newark-Jersey City, NY-NJ-PA&quot; &quot;New York-Newark-Jersey City, NY-NJ-PA&quot; ... #&gt; $ geometry:sfc_MULTIPOLYGON of length 2162; first list element: List of 3 #&gt; ..$ :List of 1 #&gt; .. ..$ : num [1:25, 1:2] -74 -74 -74 -74 -74 ... #&gt; ..$ :List of 1 #&gt; .. ..$ : num [1:5, 1:2] -74 -74 -74 -74 -74 ... #&gt; ..$ :List of 1 #&gt; .. ..$ : num [1:14, 1:2] -74 -74 -74 -74 -74 ... #&gt; ..- attr(*, &quot;class&quot;)= chr [1:3] &quot;XY&quot; &quot;MULTIPOLYGON&quot; &quot;sfg&quot; #&gt; - attr(*, &quot;sf_column&quot;)= chr &quot;geometry&quot; #&gt; - attr(*, &quot;agr&quot;)= Factor w/ 3 levels &quot;constant&quot;,&quot;aggregate&quot;,..: NA NA NA NA NA NA NA NA NA NA #&gt; ..- attr(*, &quot;names&quot;)= chr [1:10] &quot;GEOID&quot; &quot;STATEFP&quot; &quot;COUNTYFP&quot; &quot;TRACTCE&quot; ... To join the nyc_pophu data frame with nyc_census_tracts_sf we can use merge in the base package like this: nyc_sf_merged &lt;- base::merge(nyc_census_tracts_sf, nyc_pophu, by.x = &quot;GEOID&quot;, by.y = &quot;GEOID10&quot;) names(nyc_sf_merged) #&gt; [1] &quot;GEOID&quot; &quot;STATEFP.x&quot; &quot;COUNTYFP.x&quot; &quot;TRACTCE.x&quot; &quot;AFFGEOID.x&quot; #&gt; [6] &quot;NAME&quot; &quot;LSAD&quot; &quot;ALAND&quot; &quot;AWATER&quot; &quot;CBSA&quot; #&gt; [11] &quot;STATEFP.y&quot; &quot;COUNTYFP.y&quot; &quot;TRACTCE.y&quot; &quot;AFFGEOID.y&quot; &quot;POPULATION&quot; #&gt; [16] &quot;MEDAGE&quot; &quot;MEDHHINC&quot; &quot;MEDHOUSING&quot; &quot;PCPREWAR&quot; &quot;MEDYRBUILT&quot; #&gt; [21] &quot;DENSITY&quot; &quot;geometry&quot; We see the new attribute columns added, as well as the geometry column. # A basic plot to verify the data: use zcol to choose a subset of the data to plot mapview(nyc_sf_merged, zcol=c(&#39;POPULATION&#39;,&#39;MEDHHINC&#39;)) Alternatively, we can use tidyverse function join (left_join, right_join, inner_join etc) to conduct the task. Note that this requires the two matching columns being the same type. dplyr::left_join(nyc_census_tracts_sf %&gt;% dplyr::mutate(GEOID=as.numeric(as.character(GEOID))), nyc_pophu, by = c(&#39;GEOID&#39; = &#39;GEOID10&#39;)) -&gt; nyc_sf_merged names(nyc_sf_merged) 2.2 Attribute Selection (or non-spatial subsetting) sf objects are also tidyverse compatible data.frame. Using dplyr::filter, we can easy select a subset (rows) from sf data using tidyverse functions like dplyr::filter with logical expressions. The dplyr::select can select columns. high_income_tracts &lt;- nyc_sf_merged %&gt;% dplyr::filter(MEDHHINC &gt; 80000) plot(nyc_sf_merged %&gt;% st_geometry(), col=&#39;NA&#39;, border=&#39;lightblue&#39;, lwd=0.2) high_income_tracts %&gt;% st_geometry() %&gt;% plot(col=&#39;grey&#39;, border=&#39;NA&#39;, add=TRUE) 2.3 Spatial Query To perform spatial query, we must first understand spatial relationships in spatial analysis and GIScience. An excellent source for these relationships is GITTA Spatial Queries The most useful spatial (or topological) relationships are illustrated below. FIGURE 2.1: Spatial Relations And these basic relations form a hierarchy. For example, the intersects relationship actually has a few subtypes like meet (or touch), overlap, and contain, etc. Anything that is not disjoint would be an intersects. FIGURE 2.2: Hierarchy of Spatial Relations Naming rules for spatial functions sf, as well as ST_SQL in PostGIS, uses verbs for functions of spatial relationships and use nouns for functions of spatial operations. Spatial relationship functions like st_overlaps, st_covers, and st_intersects examine the topological relationships between spatial objects. Of course, some functions named by prepositions and adjectives like st_within and st_equal are only meaningful for spatial relationships. Spatial relationship functions do not produce new geometries. They just tell use their relationships, with which we can conduct query, selection, and aggregation. By contrast, spatial operations will create new geometries. For example, st_intersection will produce new geometries in sf classes. For the next example our goal is to select all census tracts that are adjacent to the central park. Think about this for a moment – what might be the steps you’d follow? ## How about: # 1. Get the census tract polygons. # 2. Find the census tract that contains the central park. # 3. Select all census tract polygons that intersect with or touch the central park tract 2.3.1 Using the sf package We will use nyc_sf_merged for the census tract polygons. Using a desktop GIS or mapview package in R, we can easily find out the GEOID of the central park tract is 36061014300. First, let’s use non-spatial query to find the central park census tract. # Note the GEOID column is a numeric type. central_partk &lt;- nyc_sf_merged %&gt;% filter(GEOID == 36061014300) Now we can use this central_park to select all census tract polygons that intersect with the tract. In order to determine the polygons we use st_intersects, a geometric binary which returns a vector of logical values, which we we can use for subsetting. Note the difference to st_intersection, which performs a geometric operation and creates a new sf object which cuts out the area of the buffer from the polygons a like cookie cutter. Let us try this: central_park_intersects &lt;- st_intersects(central_partk, nyc_sf_merged) class(central_park_intersects) We have created a sgbp object, which is a “Sparse Geometry Binary Predicate”. It is a so called sparse matrix, which is a list with integer vectors only holding the indices for each polygon that intersects. In our case we only have one vector, because we only intersect with one buffer polygon, so we can extract this first vector with central_park_intersects[[1]] and use it for subsetting: # Subsetting using the results nyc_sel_sf &lt;- nyc_sf_merged[central_park_intersects[[1]],] # or in tidyverse style nyc_sel_sf &lt;- nyc_sf_merged %&gt;% dplyr::slice(central_park_intersects[[1]]) # plot plot(st_geometry(nyc_sf_merged), border=&quot;#aaaaaa&quot;, main=&quot;Census tracts near Central Park&quot;) plot(st_geometry(nyc_sel_sf), add=T, col=&quot;lightpink&quot;) plot(st_geometry(nyc_sel_sf), add=T, col=NA, border= &#39;lightgrey&#39;,lwd = 1) # or Interactive map using mapview mapview(nyc_sel_sf) 2.4 Reprojecting or Projection Transform Occasionally we may have to change the coordinates of our spatial object into a new Coordinate Reference System (CRS). 2.4.1 Transform or reproject sf objects Let us check nyc_sf_merged object and reproject it to a local projection in State Plane Long Island, that is the local map projection the NYC. st_crs(nyc_sf_merged) #&gt; Coordinate Reference System: #&gt; User input: NAD83 #&gt; wkt: #&gt; GEOGCRS[&quot;NAD83&quot;, #&gt; DATUM[&quot;North American Datum 1983&quot;, #&gt; ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, #&gt; LENGTHUNIT[&quot;metre&quot;,1]]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; CS[ellipsoidal,2], #&gt; AXIS[&quot;latitude&quot;,north, #&gt; ORDER[1], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; AXIS[&quot;longitude&quot;,east, #&gt; ORDER[2], #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; ID[&quot;EPSG&quot;,4269]] # then we transform/reproject it to SPCS Long Island, 2831 nyc_sf_2831 &lt;- st_transform(nyc_sf_merged, 2831) st_crs(nyc_sf_2831) #&gt; Coordinate Reference System: #&gt; User input: EPSG:2831 #&gt; wkt: #&gt; PROJCRS[&quot;NAD83(HARN) / New York Long Island&quot;, #&gt; BASEGEOGCRS[&quot;NAD83(HARN)&quot;, #&gt; DATUM[&quot;NAD83 (High Accuracy Reference Network)&quot;, #&gt; ELLIPSOID[&quot;GRS 1980&quot;,6378137,298.257222101, #&gt; LENGTHUNIT[&quot;metre&quot;,1]]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433]], #&gt; ID[&quot;EPSG&quot;,4152]], #&gt; CONVERSION[&quot;SPCS83 New York Long Island zone (meters)&quot;, #&gt; METHOD[&quot;Lambert Conic Conformal (2SP)&quot;, #&gt; ID[&quot;EPSG&quot;,9802]], #&gt; PARAMETER[&quot;Latitude of false origin&quot;,40.1666666666667, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8821]], #&gt; PARAMETER[&quot;Longitude of false origin&quot;,-74, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8822]], #&gt; PARAMETER[&quot;Latitude of 1st standard parallel&quot;,41.0333333333333, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8823]], #&gt; PARAMETER[&quot;Latitude of 2nd standard parallel&quot;,40.6666666666667, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8824]], #&gt; PARAMETER[&quot;Easting at false origin&quot;,300000, #&gt; LENGTHUNIT[&quot;metre&quot;,1], #&gt; ID[&quot;EPSG&quot;,8826]], #&gt; PARAMETER[&quot;Northing at false origin&quot;,0, #&gt; LENGTHUNIT[&quot;metre&quot;,1], #&gt; ID[&quot;EPSG&quot;,8827]]], #&gt; CS[Cartesian,2], #&gt; AXIS[&quot;easting (X)&quot;,east, #&gt; ORDER[1], #&gt; LENGTHUNIT[&quot;metre&quot;,1]], #&gt; AXIS[&quot;northing (Y)&quot;,north, #&gt; ORDER[2], #&gt; LENGTHUNIT[&quot;metre&quot;,1]], #&gt; USAGE[ #&gt; SCOPE[&quot;Engineering survey, topographic mapping.&quot;], #&gt; AREA[&quot;United States (USA) - New York - counties of Bronx; Kings; Nassau; New York; Queens; Richmond; Suffolk.&quot;], #&gt; BBOX[40.47,-74.26,41.3,-71.8]], #&gt; ID[&quot;EPSG&quot;,2831]] We see that the CRS are different for the two. One is geographic coordinate systems (longitude, latitude) using NAD83 and the other is New York State Plane Long Island. We can also see the proj4 strings of the two. st_crs(nyc_sf_merged)$proj4string st_crs(nyc_sf_2831)$proj4string : we have +proj=lcc... and +proj=longlat.... LCC refers to Lambert Conic Conformal, which is a projected coordinate system with numeric units. We can use the st_bbox() method from the sf package to compare the coordinates before and after transformation and confirm that we actually have transformed them. st_bbox() returns the min and max values of the two dimensions of a sf spatial object. sf::st_bbox(nyc_sf_merged) # bounding box #&gt; xmin ymin xmax ymax #&gt; -74.25559 40.50210 -73.70002 40.91526 st_bbox(nyc_sf_2831) #&gt; xmin ymin xmax ymax #&gt; 278336.44 37278.33 325338.38 83132.41 We can also compare them visually with: par(mfrow=c(1,2)) plot(st_geometry(nyc_sf_merged), axes=TRUE, main = &quot;before transform - latlon&quot;) plot(st_geometry(nyc_sf_2831), axes=TRUE, main = &quot;after transform - lcc&quot;) Lastly, let us save the reprojected file as nyc_tracts_2831 Shapefile, as we may use it later on. st_write(nyc_sf_2831, &#39;data/nyc/nyc_tracts_2831.shp&#39;) Set CRS and Reproject (transform) Assigning a new CRS to a spatial object does not change its coordinates but the CRS determines how the software understand the coordinates. So, we must choose and set a CRS that is consistent with the coordinates. Otherwise, the coordinates will be misinterpreted. Reprojecting spatial data with st_transform and gTransform really changes the underlying coordinates, which we can see from the bbox values. In either case, the CRS must be consistent with the coordinates. It is a good practice to check projected spatial data against a basemap or a correctly referenced map to verify its CRS. SpatialReference.org is a very good source for CRS information. Some commonly used reference systems US 48 Contiguous States: Albers Equal Area (ESRI:102003), Lambert Conformal (ESRI:102004) New York State: UTM 18N (EPSG 3725, 3748, 26918) New York City: State Plane Long Island (EPSG 2263, 2831, 3627) 2.4.2 Spatial Query with Reprojection Another scenario where we need to transform spatial data into a different projection is to apply distances. This is because local projections tend to minimize distortion and they also use units like meter or feet. Here we use a distance buffer example to illustrate both transformation/reprojection and spatial query. In this example, we try to find the noise complaint within 200 meter from Hunter College, 09/01/2019 to 09/01/2020. First, we search the geographic coordinates of Hunter College and find (-73.9645, 40.7678). Then, we create a spatial object for this location. As we don’t really use any attribute information for this location, a sfc object is sufficient. # make a simple feature point with CRS hunter_college_sfc &lt;- st_sfc(st_point(c(-73.9645, 40.7678)), crs = 4269) # Verify the location using mapview with basemap or ggmaps mapview(hunter_college_sfc) We can also use what we learned earlier to directly create a sf object. # make a simple feature point with CRS hunter_college_sf &lt;- st_as_sf(data.frame(x=-73.9645, y=40.7678), coords = c(&#39;x&#39;,&#39;y&#39;), crs = 4269) # Verify the location using mapview with basemap or ggmaps mapview(hunter_college_sf) Now, let’s read the Manhattan noise data and check on their coordinate systems. If they have the same CRS with a unit of meter, we can use them directly. Otherwise, we have to convert them to a local map projection with a meter unit. man_noise_sf &lt;- sf::st_read(&#39;data/nyc/ManhattanNoise.shp&#39;) st_crs(hunter_college_sf) st_crs(man_noise_sf) It turns out both use geographic coordinates with a unit of decimal degree. But one is using WGS84 (4326) and the other is using NAD83 (4326). Although they are very similar to each other, none of them have a unit of meter. So, we must convert both to the same CRS using New York Long Island (State Plain Coordinate System, SPCS) with a unit of meter. The SRID is 2831. Note 2263 is also New York Long Island, but its unit is feet. To avoid saving all the intermediate results, we use pipe %&gt;% to get the buffer and to conduct the spatial query. hunter_college_sf %&gt;% sf::st_transform(2831) %&gt;% # transform the data to 2831 sf::st_buffer(200) %&gt;% # create the buffer sf::st_intersects(man_noise_sf # intersects with the transformed noise data %&gt;% st_transform(2831)) %&gt;% magrittr::extract2(., 1) %&gt;% # Get the indices of the noise points within 200 meter buffer dplyr::slice(man_noise_sf, .) %&gt;% # Get those noise points mapview::mapview() # Map them out using a simple interactive map This chunk of code may be difficult to understand. You can break it down and explicitly save the intermediate data using variables. 2.4.3 Raster reprojection Here is what it would look like to reproject the HARV raster used earlier to a WGS84 projection. We see that the original projection is in UTM. # if you need to load again: #HARV &lt;- raster(&quot;data/HARV_RGB_Ortho.tif&quot;) raster::crs(HARV) #&gt; Coordinate Reference System: #&gt; Deprecated Proj.4 representation: #&gt; +proj=utm +zone=18 +datum=WGS84 +units=m +no_defs #&gt; WKT2 2019 representation: #&gt; PROJCRS[&quot;unknown&quot;, #&gt; BASEGEOGCRS[&quot;unknown&quot;, #&gt; DATUM[&quot;World Geodetic System 1984&quot;, #&gt; ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, #&gt; LENGTHUNIT[&quot;metre&quot;,1]], #&gt; ID[&quot;EPSG&quot;,6326]], #&gt; PRIMEM[&quot;Greenwich&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8901]]], #&gt; CONVERSION[&quot;UTM zone 18N&quot;, #&gt; METHOD[&quot;Transverse Mercator&quot;, #&gt; ID[&quot;EPSG&quot;,9807]], #&gt; PARAMETER[&quot;Latitude of natural origin&quot;,0, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8801]], #&gt; PARAMETER[&quot;Longitude of natural origin&quot;,-75, #&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #&gt; ID[&quot;EPSG&quot;,8802]], #&gt; PARAMETER[&quot;Scale factor at natural origin&quot;,0.9996, #&gt; SCALEUNIT[&quot;unity&quot;,1], #&gt; ID[&quot;EPSG&quot;,8805]], #&gt; PARAMETER[&quot;False easting&quot;,500000, #&gt; LENGTHUNIT[&quot;metre&quot;,1], #&gt; ID[&quot;EPSG&quot;,8806]], #&gt; PARAMETER[&quot;False northing&quot;,0, #&gt; LENGTHUNIT[&quot;metre&quot;,1], #&gt; ID[&quot;EPSG&quot;,8807]], #&gt; ID[&quot;EPSG&quot;,16018]], #&gt; CS[Cartesian,2], #&gt; AXIS[&quot;(E)&quot;,east, #&gt; ORDER[1], #&gt; LENGTHUNIT[&quot;metre&quot;,1, #&gt; ID[&quot;EPSG&quot;,9001]]], #&gt; AXIS[&quot;(N)&quot;,north, #&gt; ORDER[2], #&gt; LENGTHUNIT[&quot;metre&quot;,1, #&gt; ID[&quot;EPSG&quot;,9001]]]] HARV_WGS84 &lt;- projectRaster(HARV, crs=CRS(&quot;+proj=longlat +datum=WGS84&quot;)) Let’s look at the coordinates to see the effect: extent(HARV) #&gt; class : Extent #&gt; xmin : 731998.5 #&gt; xmax : 732766.8 #&gt; ymin : 4712956 #&gt; ymax : 4713536 extent(HARV_WGS84) #&gt; class : Extent #&gt; xmin : -72.17505 #&gt; xmax : -72.16544 #&gt; ymin : 42.53393 #&gt; ymax : 42.5394 ncell(HARV) #&gt; [1] 7120141 ncell(HARV_WGS84) #&gt; [1] 7687552 And here is the visual proof: plot(HARV, main = &quot;before transform - UTM&quot;) plot(HARV_WGS84, main = &quot;after transform - WGS84&quot;) 2.5 Spatial Join and Aggregation: Points in Polygons Now that we have both noise and census tracts we will forge ahead and ask for the density of noise complaint for each census tract in Manhattan: \\(\\frac{{noise complaints}}{area}\\) To achieve this this we join the points of noise complaints to the census tract polygon and count them up for each polygon. You might be familiar with this operation from ArcGIS, QGIS, or other GIS packages. Note that for topological relationships not based on distances, it will work as long as both data have the same coordinate systems. 2.5.1 With sf We will use piping and build up our object in the following way. First we calculate the area for each tract. We use the st_area function on the geometry column and add the result. nyc_census_tracts_sf %&gt;% filter(COUNTYFP == &#39;061&#39;) %&gt;% mutate(tract_area = st_area(geometry)) %&gt;% head() Next, we use st_join to perform a spatial join with the points: nyc_census_tracts_sf %&gt;% filter(COUNTYFP == &#39;061&#39;) %&gt;% mutate(tract_area = st_area(geometry)) %&gt;% st_transform(4326) %&gt;% st_join(man_noise_sf) %&gt;% head() Now we can group by a variable that unique identifies the census tracts, (we choose GEOID) and use summarize to count the points for each tract and calculate the rate of noise complaints. Since our units are in sq meter. multiply by by 1000000 to get sq km. We also need to carry over the area, which we can use max, min, mean, or unique as all the values are the same for the same census tract. We also assign the output to a new object noise_rate. noise_rate_sf &lt;- nyc_census_tracts_sf %&gt;% filter(COUNTYFP == &#39;061&#39;) %&gt;% mutate(tract_area = st_area(geometry)) %&gt;% st_transform(4326) %&gt;% st_join(man_noise_sf) %&gt;% group_by(GEOID) %&gt;% summarize(n_noise = n(), tract_area = max(tract_area), noise_rate = n_noise/tract_area * 1e6) And here is a simple plot: mapview(noise_rate_sf, zcol=&#39;noise_rate&#39;, legend=FALSE) Finally, we write this out for later: st_write(noise_rate_sf, &quot;data/nyc/man_noise_rate.shp&quot;, delete_layer = TRUE) 2.5.2 sp - sf comparison how to.. for sp objects for sf objects join attributes sp::merge() dplyr::*_join() (also sf::merge()) reproject spTransform() st_transform() retrieve (or assign) CRS proj4string() st_crs() count points in polygons aggregate() or over() st_within() or aggregate() buffer rgeos::gBuffer() (separate package) st_buffer() select by location g* functions from rgeos st_* geos functions in sf Here are some additional packages that use vector data: stplanr: Functionality and data access tools for transport planning, including origin-destination analysis, route allocation and modelling travel patterns. bikedata: Data from public hire bicycle systems,including London, New York, Chicago, Washington DC, Boston, Los Angles, and Philadelphia 2.6 Spatial Operations 2.6.1 Spatial Measures This type of operations measure certain values from spatial objects. For example, we can derive the boundary box and centroid using sf::st_bbox and sf::st_centroid. More basic measures are areas and length with sf::st_area and sf::st_length. 2.6.2 Geometric Operations More interestingly, we can conduct certain geometric operations such as buffer and overlay. In spatial analysis, overlay contains a few types. FIGURE 2.3: Overlay Types And this web page has an excellent explanation to the spatial operations on vector data, including buffer, operations involving one (unary) or multiple layers of spatial objects. FIGURE 2.4: Buffer Options: (a) Variable Width Buffers, (b) Multiple Ring Buffers, (c) Doughnut Buffer, (d) Setback Buffer, (e) Nondissolved Buffer, (f) Dissolved Buffer FIGURE 2.5: Single Layer Geometric Operations FIGURE 2.6: Multiple Layer Geometric Operations Self Exercise Think about how to conduct these spatial operations using basic sf st_ and tidyverse functions. Dissolve: merge (data.frame), dplyr::group_by, st_union Append: dplyr::bind_rows, st_combine (may not give you what you expect, though) Identity: st_union and then st_intersection Erase: st_difference Split: st_intersection by feature ID Geometric operations are algorithmically difficult and computationally expensive. So, quite often, results are not what we expected. More mature packages perform better. In this case, sp-family packages are better than sf-family. buf_sf &lt;- hunter_college_sf %&gt;% sf::st_transform(2831) %&gt;% # reproject the data to 2831 sf::st_buffer(800) # create the buffer man_tracts_sf &lt;- nyc_census_tracts_sf %&gt;% st_transform(2831) %&gt;% filter(COUNTYFP == &#39;061&#39;) buf_sel_sf &lt;- buf_sf %&gt;% sf::st_intersects(man_tracts_sf) %&gt;% # intersects with the transformed noise data magrittr::extract2(., 1) %&gt;% # Get the indices of the noise points within 200 meter buffer dplyr::slice(man_tracts_sf, .) par(mfrow=c(1,2), mar = c(4, 0.1, 0.8, 0.1)) plot(buf_sf %&gt;% st_geometry(), col=&#39;grey&#39;, main = &#39;Buffer Geometry&#39;) plot(buf_sel_sf %&gt;% st_geometry(), col=&#39;lightskyblue2&#39;, main=&quot;Polygons&quot;) st_union(buf_sel_sf, buf_sf,by_feature = TRUE) %&gt;% st_geometry() %&gt;% plot(col=&#39;lightskyblue1&#39;, main = &#39;sf::st_union by feature&#39;) rgeos::gUnion(buf_sf %&gt;% sf::as_Spatial(), buf_sel_sf %&gt;% sf::as_Spatial(), byid = TRUE) %&gt;% plot(col=&#39;lightpink&#39;, main = &#39;rgeos::gUnion (sp) by feature&#39;) st_union(buf_sel_sf, buf_sf,by_feature = FALSE) %&gt;% st_geometry() %&gt;% plot(col=&#39;lightskyblue1&#39;, main = &#39;sf::st_union&#39;) rgeos::gUnion(buf_sf %&gt;% sf::as_Spatial(), buf_sel_sf %&gt;% sf::as_Spatial()) %&gt;% plot(col=&#39;lightpink&#39;, main = &#39;rgeos::gUnion (sp)&#39;) st_intersection(buf_sel_sf, buf_sf) %&gt;% st_geometry() %&gt;% plot(col=&#39;lightskyblue1&#39;, main = &#39;sf::st_intersection&#39;) st_difference(buf_sel_sf, buf_sf) %&gt;% st_geometry() %&gt;% plot(col=&#39;lightskyblue1&#39;,main = &#39;sf::st_difference&#39;) st_sym_difference(buf_sel_sf, buf_sf) %&gt;% st_geometry() %&gt;% plot(col=&#39;lightskyblue1&#39;,main = &#39;sf::st_sym_difference&#39;) rgeos::gSymdifference(buf_sf %&gt;% sf::as_Spatial(), buf_sel_sf %&gt;% sf::as_Spatial(), drop_lower_td = TRUE) %&gt;% plot(col=&#39;lightpink&#39;, main = &#39;rgeos::gSymdifference (sp)&#39;) Interestingly, the raster package seems to have better intersect and union methods. Results from these methods are similar to what popular GIS software like ArcGIS produces. More importantly, they keep all the attributes from both layers. par(mfrow=c(1,2), mar = c(4, 0.1, 0.8, 0.1)); raster::union(buf_sf %&gt;% sf::st_geometry() %&gt;% sf::as_Spatial(), buf_sel_sf %&gt;% sf::st_geometry() %&gt;% sf::as_Spatial()) %&gt;% plot(col=&#39;lightpink&#39;, main = &#39;raster::union&#39;); raster::intersect(buf_sf %&gt;% sf::st_geometry() %&gt;% sf::as_Spatial(), buf_sel_sf %&gt;% sf::st_geometry() %&gt;% sf::as_Spatial()) %&gt;% plot(col=&#39;lightpink&#39;, main = &#39;raster::intersect&#39;) To visualize all these different operations with the original dataset. # Various types of spatial operations par(mfrow=c(1,2), mar = c(4, 0.1, 0.8, 0.1)) plot(st_geometry(man_tracts_sf), border=&quot;#aaaaaa&quot;, main=&quot;Buffer Geometry&quot;) plot(buf_sf %&gt;% st_geometry(), col=&#39;grey&#39;, add=T) plot(st_geometry(man_tracts_sf), border=&quot;#aaaaaa&quot;, main=&quot;Polygons&quot;) plot(buf_sel_sf %&gt;% st_geometry(), col=&#39;lightskyblue2&#39;, add=T) plot(st_geometry(man_tracts_sf), border=&quot;#aaaaaa&quot;, main=&quot;sf::st_union by feature&quot;) st_union(buf_sel_sf, buf_sf,by_feature = TRUE) %&gt;% st_geometry() %&gt;% plot(col=&#39;lightskyblue1&#39;, add = T) plot(st_geometry(man_tracts_sf), border=&quot;#aaaaaa&quot;, main=&#39;rgeos::gUnion (sp) by feature&#39;) rgeos::gUnion(buf_sf %&gt;% sf::as_Spatial(), buf_sel_sf %&gt;% sf::as_Spatial(), byid = TRUE) %&gt;% plot(col=&#39;lightpink&#39;, add = T) plot(st_geometry(man_tracts_sf), border=&quot;#aaaaaa&quot;, main=&#39;sf::st_untion&#39;) st_union(buf_sel_sf, buf_sf,by_feature = FALSE) %&gt;% st_geometry() %&gt;% plot(col=&#39;lightskyblue1&#39;, add = T) plot(st_geometry(man_tracts_sf), border=&quot;#aaaaaa&quot;, main=&#39;rgeos::gUnion (sp)&#39;) rgeos::gUnion(buf_sf %&gt;% sf::as_Spatial(), buf_sel_sf %&gt;% sf::as_Spatial()) %&gt;% plot(col=&#39;lightpink&#39;, add = T) plot(st_geometry(man_tracts_sf), border=&quot;#aaaaaa&quot;, main=&#39;sf::st_intersection&#39;) st_intersection(buf_sel_sf, buf_sf) %&gt;% st_geometry() %&gt;% plot(col=&#39;lightskyblue1&#39;, add = T) plot(st_geometry(man_tracts_sf), border=&quot;#aaaaaa&quot;, main=&#39;sf::st_difference&#39;) st_difference(buf_sel_sf, buf_sf) %&gt;% st_geometry() %&gt;% plot(col=&#39;lightskyblue1&#39;, add = T) plot(st_geometry(man_tracts_sf), border=&quot;#aaaaaa&quot;, main=&#39;sf::st_sym_difference&#39;) st_sym_difference(buf_sel_sf, buf_sf) %&gt;% st_geometry() %&gt;% plot(col=&#39;lightskyblue1&#39;, add = T) plot(st_geometry(man_tracts_sf), border=&quot;#aaaaaa&quot;, main=&#39;rgeos::gSysdifference (sp)&#39;) rgeos::gSymdifference(buf_sf %&gt;% sf::as_Spatial(), buf_sel_sf %&gt;% sf::as_Spatial(), drop_lower_td = TRUE) %&gt;% plot(col=&#39;lightpink&#39;, add = T) par(mfrow=c(1,2), mar = c(4, 0.1, 0.8, 0.1)) plot(st_geometry(man_tracts_sf), border=&quot;#aaaaaa&quot;, main=&#39;raster::union&#39;) raster::union(buf_sf %&gt;% sf::st_geometry() %&gt;% sf::as_Spatial(), buf_sel_sf %&gt;% sf::st_geometry() %&gt;% sf::as_Spatial()) %&gt;% plot(col=&#39;lightpink&#39;, add = T) plot(st_geometry(man_tracts_sf), border=&quot;#aaaaaa&quot;, main=&#39;raster::instersect&#39;) raster::intersect(buf_sf %&gt;% sf::st_geometry() %&gt;% sf::as_Spatial(), buf_sel_sf %&gt;% sf::st_geometry() %&gt;% sf::as_Spatial()) %&gt;% plot(col=&#39;lightpink&#39;, add = T) Earlier, we used group_by + summarize (sf) and aggregate (sp) to conduct spatial aggregation or spatial join. When these functions apply to a single spatial object (unary operations), they could do the dissolve. Note that those internal “sliver” polygons are caused by inaccurate boundaries. For example, two neighboring polygons should have exactly the same boundary at where they touch. But if not, those sliver polygons will be produced during spatial operations. That also partially explains why sf performs very bad because sf assumes data strictly following Simple Features specifications. Obviously, the NYC data do not. par(mfrow=c(1,2), mar = c(4, 0.1, 0.8, 0.1)); nyc_sf_merged %&gt;% dplyr::mutate(incomeFactor = cut(MEDHHINC, c(0, 30000, 80000, Inf), c(&#39;Low&#39;, &#39;Medium&#39;, &#39;High&#39;))) %&gt;% dplyr::select(incomeFactor, geometry ) %&gt;% group_by(incomeFactor) %&gt;% summarise() %&gt;% plot(main=&quot;group_by+summarize&quot;); groupFactor &lt;- cut(nyc_sf_merged$MEDHHINC, c(0, 30000, 80000, Inf), c(&#39;Low&#39;, &#39;Medium&#39;, &#39;High&#39;)); nyc_sf_merged %&gt;% dplyr::select(MEDHHINC, geometry ) %&gt;% aggregate(by = list(FemDocLevel = groupFactor), sum) %&gt;% magrittr::extract(&#39;FemDocLevel&#39;) %&gt;% plot(main=&quot;dissolve by aggregate&quot;) 2.7 Information for Raster Operations Some helpful packages that deal with raster data: landscapetools provides utility functions to complete tasks involved in common landscape analysis. getlandsat: Get Landsat 8 Data from Amazon Public Data Sets MODIStsp: automates the creation of time series of rasters derived from MODIS Land Products data FedData: Download geospatial Data from federated data sources, including the The National Elevation Dataset digital elevation models, the Global Historical Climatology Network, the National Land Cover Database, and more. 2.8 Lab Assignment The second lab is to aggregate data from different sources to the zip codes as the core covid-19 data are available at that scale. Main tasks for the second lab are: Join the COVID-19 data to the NYC zip code area data (sf or sp polygons). Aggregate the NYC food retails store data (points) to the zip code data, so that we know how many retail stores in each zip code area. Note that not all locations are for food retail. And we need to choose the specific types according to the data. Aggregate the NYC health facilities (points) to the zip code data. Similarly, choose appropriate subtypes such as nursing homes from the facilities. Join the Census ACS population, race, and age data to the NYC Planning Census Tract Data. Aggregate the ACS census data to zip code area data. In the end, we should have the confirmed and tested cases of covid-19, numbers of specific types of food stores, numbers of specific types of health facilities, and population (total population, elderly, by race, etc.) at the zip code level. We should also have boroughs, names, etc. for each zip code area. Lovelace, R., Nowosad, J., &amp; Muenchow, J. (2019). Geocomputation with R. CRC Press.↩︎ Per the ESRI specification a Shapefile must have an attribute table, so when we read it into R with the readOGR command from the sp package it automatically becomes a Spatial*Dataframe and the attribute table becomes the data.frame.↩︎ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
